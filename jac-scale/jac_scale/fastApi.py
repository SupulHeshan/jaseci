"""
JFastApiServer: A FastAPI Implementation of JServer

This module provides a FastAPI-specific implementation of the JServer abstract base class.
It handles endpoint registration with FastAPI applications and provides all the FastAPI-specific
functionality like parameter injection, response model generation, and route creation.

Key Components:
- JFastApiServer: FastAPI implementation of JServer
- create_app(): Creates a basic FastAPI application for demonstration

Advanced Features:
- Parameter injection with type conversion
- Response model generation from JSON schema
- Support for async/sync callback functions
- Automatic OpenAPI documentation generation
- Integration with JAC pass execution patterns
"""

import inspect
from typing import Any, Callable, Dict, List, Optional, Type

from fastapi import Body, FastAPI, HTTPException, Header, Path, Query

from pydantic import BaseModel, Field, create_model

# Import from the separated jserver module
from .jserver import HTTPMethod, JEndPoint, JServer, ParameterType


class JFastApiServer(JServer[FastAPI]):
    """
    A FastAPI implementation of JServer for programmatic endpoint creation.

    JFastApiServer provides FastAPI-specific implementation of the JServer interface,
    handling endpoint registration with FastAPI applications.

    This class implements the JServer interface by:
    - Storing registered endpoints internally
    - Implementing HTTP method handlers (_get, _post, _put, _patch, _delete)
    - Providing FastAPI app instance for server execution

    Example:
        >>> # Create server with endpoints
        >>> endpoints = [
        ...     JEndPoint(HTTPMethod.GET, "/users", get_users_callback),
        ...     JEndPoint(HTTPMethod.POST, "/users", create_user_callback)
        ... ]
        >>> server = JFastApiServer(endpoints)
        >>>
        >>> # Execute to create FastAPI routes
        >>> server.execute()
        >>> app = server.create_server()

    Attributes:
        app (FastAPI): The underlying FastAPI application instance
    """

    def __init__(
        self, endpoints: Optional[List[JEndPoint]] = None, app: Optional[FastAPI] = None
    ) -> None:
        # Initialize with endpoints (empty list if none provided)
        super().__init__(endpoints or [])
        self.app = app or FastAPI()
        self._models: Dict[str, Type[BaseModel]] = {}

    def _get(self, endpoint: JEndPoint) -> "JFastApiServer":
        """
        Handle execution of a GET endpoint by registering it with FastAPI.

        Args:
            endpoint (JEndPoint): The GET endpoint to execute

        Returns:
            JFastApiServer: Self for method chaining
        """
        self._create_fastapi_route(HTTPMethod.GET, endpoint)
        return self

    def _post(self, endpoint: JEndPoint) -> "JFastApiServer":
        """
        Handle execution of a POST endpoint by registering it with FastAPI.

        Args:
            endpoint (JEndPoint): The POST endpoint to execute

        Returns:
            JFastApiServer: Self for method chaining
        """
        self._create_fastapi_route(HTTPMethod.POST, endpoint)
        return self

    def _put(self, endpoint: JEndPoint) -> "JFastApiServer":
        """
        Handle execution of a PUT endpoint by registering it with FastAPI.

        Args:
            endpoint (JEndPoint): The PUT endpoint to execute

        Returns:
            JFastApiServer: Self for method chaining
        """
        self._create_fastapi_route(HTTPMethod.PUT, endpoint)
        return self

    def _patch(self, endpoint: JEndPoint) -> "JFastApiServer":
        """
        Handle execution of a PATCH endpoint by registering it with FastAPI.

        Args:
            endpoint (JEndPoint): The PATCH endpoint to execute

        Returns:
            JFastApiServer: Self for method chaining
        """
        self._create_fastapi_route(HTTPMethod.PATCH, endpoint)
        return self

    def _delete(self, endpoint: JEndPoint) -> "JFastApiServer":
        """
        Handle execution of a DELETE endpoint by registering it with FastAPI.

        Args:
            endpoint (JEndPoint): The DELETE endpoint to execute

        Returns:
            JFastApiServer: Self for method chaining
        """
        self._create_fastapi_route(HTTPMethod.DELETE, endpoint)
        return self

    def create_server(self) -> FastAPI:
        """
        Create a complete FastAPI server with all endpoints registered.

        This method executes all registered endpoints to create FastAPI routes
        and returns the configured FastAPI application.

        Returns:
            FastAPI: The configured FastAPI application instance
        """
        self.execute()
        return self.app

    def _create_fastapi_route(self, method: HTTPMethod, endpoint: JEndPoint) -> None:
        """
        Create and register a FastAPI route for the given endpoint.

        Args:
            method (HTTPMethod): The HTTP method for the route
            endpoint (JEndPoint): The endpoint configuration
        """
        # Create wrapper function with proper parameter handling
        endpoint_func = self._create_endpoint_function(
            endpoint.callback,
            endpoint.parameters or [],
            [],  # dependencies not yet implemented in JEndPoint
        )

        # Set up route options with proper typing
        route_kwargs: Dict[str, Any] = {
            "response_model": endpoint.response_model,
            "status_code": self._get_default_status_code(method),
            "summary": endpoint.summary or f"{method.value} {endpoint.path}",
            "description": endpoint.description
            or (endpoint.callback.__doc__ if endpoint.callback.__doc__ else ""),
            "tags": endpoint.tags or [],
        }

        # Register the route with FastAPI
        if method == HTTPMethod.GET:
            self.app.get(endpoint.path, **route_kwargs)(endpoint_func)
        elif method == HTTPMethod.POST:
            self.app.post(endpoint.path, **route_kwargs)(endpoint_func)
        elif method == HTTPMethod.PUT:
            self.app.put(endpoint.path, **route_kwargs)(endpoint_func)
        elif method == HTTPMethod.PATCH:
            self.app.patch(endpoint.path, **route_kwargs)(endpoint_func)
        elif method == HTTPMethod.DELETE:
            self.app.delete(endpoint.path, **route_kwargs)(endpoint_func)

    def _get_default_status_code(self, method: HTTPMethod) -> int:
        """Get the default status code for an HTTP method."""
        status_codes = {
            HTTPMethod.GET: 200,
            HTTPMethod.POST: 201,
            HTTPMethod.PUT: 200,
            HTTPMethod.PATCH: 200,
            HTTPMethod.DELETE: 204,
        }
        return status_codes.get(method, 200)

    def _create_endpoint_function(
        self,
        callback: Callable[..., Any],
        parameters: List[Dict[str, Any]],
        dependencies: List[Any],
    ) -> Callable[..., Any]:
        """Create the actual endpoint function with parameter injection."""

        # If no parameters, create a simple wrapper
        if not parameters:
            if inspect.iscoroutinefunction(callback):

                async def async_endpoint_wrapper() -> None:
                    try:
                        await callback()
                    except Exception as e:
                        raise HTTPException(status_code=500, detail=str(e))

                return async_endpoint_wrapper
            else:

                def sync_endpoint_wrapper() -> None:
                    try:
                        callback()
                    except Exception as e:
                        raise HTTPException(status_code=500, detail=str(e))

                return sync_endpoint_wrapper

        # Group parameters by location
        body_params: List[Dict[str, Any]] = []
        path_params: List[Dict[str, Any]] = []
        query_params: List[Dict[str, Any]] = []
        header_params: List[Dict[str, Any]] = []

        for param in parameters:
            param_location = param.get("in", ParameterType.QUERY)
            if param_location == ParameterType.BODY:
                body_params.append(param)
            elif param_location == ParameterType.PATH:
                path_params.append(param)
            elif param_location == ParameterType.QUERY:
                query_params.append(param)
            elif param_location == ParameterType.HEADER:
                header_params.append(param)

        # Build parameter strings and their FastAPI annotations
        param_strs: List[str] = []
        param_mapping: Dict[str, str] = {}

        # Handle body parameters - if multiple, create a single Body model
        body_model: Optional[Type[BaseModel]] = None

        if len(body_params) > 1:
            # Create a dynamic Pydantic model for multiple body parameters
            model_fields: Dict[str, Any] = {}
            for param in body_params:
                param_name = param.get("name")
                if not param_name:
                    continue
                param_type = self._get_python_type(param.get("type", "str"))
                required = param.get("required", True)
                description = param.get("description", "")

                if required:
                    model_fields[param_name] = (
                        param_type,
                        Field(..., description=description),
                    )
                else:
                    default_value = param.get("default")
                    model_fields[param_name] = (
                        Optional[param_type],
                        Field(default_value, description=description),
                    )

            # Create the model
            if model_fields:
                body_model = create_model("RequestBody", **model_fields)  # type: ignore[misc]
                param_strs.append("body_data: RequestBody")
                param_mapping["body_data"] = "body_data"
        elif len(body_params) == 1:
            # Single body parameter
            param = body_params[0]
            param_name = param.get("name")
            param_type: str = param.get("type", "str")
            required = param.get("required", True)
            default_value = param.get("default")
            description = param.get("description", "")

            actual_type = self._get_python_type(param_type)
            type_name = actual_type.__name__

            if required:
                param_str = (
                    f"{param_name}: {type_name} = "
                    f"Body(..., description='{description}')"
                )
            else:
                param_str = (
                    f"{param_name}: Optional[{type_name}] = "
                    f"Body({repr(default_value)}, description='{description}')"
                )

            param_strs.append(param_str)
            if param_name:
                param_mapping[param_name] = param_name

        # Handle other parameter types (path, query, header)
        param_type_mapping = [
            (path_params, ParameterType.PATH),
            (query_params, ParameterType.QUERY),
            (header_params, ParameterType.HEADER),
        ]

        for param_list, param_type_enum in param_type_mapping:
            for param in param_list:
                param_name = param.get("name")
                if not param_name:
                    continue

                # Ensure param_name is a string
                if not isinstance(param_name, str):
                    continue

                param_type = param.get("type", "str")
                required = param.get("required", True)
                default_value = param.get("default")
                description = param.get("description", "")

                # Convert string type to actual type
                actual_type = self._get_python_type(param_type)
                type_name = actual_type.__name__

                # Create parameter definition
                if param_type_enum == ParameterType.PATH:
                    if required:
                        param_str = (
                            f"{param_name}: {type_name} = "
                            f"Path(..., description='{description}')"
                        )
                    else:
                        param_str = (
                            f"{param_name}: Optional[{type_name}] = "
                            f"Path({repr(default_value)}, description='{description}')"
                        )
                elif param_type_enum == ParameterType.QUERY:
                    if required:
                        param_str = (
                            f"{param_name}: {type_name} = "
                            f"Query(..., description='{description}')"
                        )
                    else:
                        param_str = (
                            f"{param_name}: Optional[{type_name}] = "
                            f"Query({repr(default_value)}, description='{description}')"
                        )
                elif param_type_enum == ParameterType.HEADER:
                    if required:
                        param_str = (
                            f"{param_name}: {type_name} = "
                            f"Header(..., description='{description}')"
                        )
                    else:
                        param_str = (
                            f"{param_name}: Optional[{type_name}] = "
                            f"Header({repr(default_value)}, description='{description}')"
                        )
                else:
                    continue

                param_strs.append(param_str)
                param_mapping[param_name] = param_name

        # Create function signature
        params = ", ".join(param_strs)

        # Build callback arguments assignment
        callback_args_lines: List[str] = []
        if body_model:
            # Handle body model case
            for param in body_params:
                param_name = param.get("name")
                if param_name:
                    callback_args_lines.append(
                        f"        callback_args['{param_name}'] = body_data.{param_name}"
                    )

            # Add other parameters
            for name in param_mapping.keys():
                if name != "body_data":
                    callback_args_lines.append(
                        f"        callback_args['{name}'] = {name}"
                    )
        else:
            # Handle normal case
            callback_args_lines = [
                f"        callback_args['{name}'] = {name}"
                for name in param_mapping.keys()
            ]

        callback_args_str = "\n".join(callback_args_lines)

        # Create function code
        if inspect.iscoroutinefunction(callback):
            func_code = f"""
async def endpoint_wrapper({params}) -> Any:
    try:
        callback_args: Dict[str, Any] = {{}}
{callback_args_str}
        result = await callback(**callback_args)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
"""
        else:
            func_code = f"""
def endpoint_wrapper({params}) -> Any:
    try:
        callback_args: Dict[str, Any] = {{}}
{callback_args_str}
        result = callback(**callback_args)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
"""

        # Prepare execution context
        exec_globals: Dict[str, Any] = {
            "callback": callback,
            "HTTPException": HTTPException,
            "Query": Query,
            "Path": Path,
            "Body": Body,
            "Header": Header,
            "Optional": Optional,
            "Field": Field,
            "create_model": create_model,
            "Dict": Dict,
            "Any": Any,
            "int": int,
            "str": str,
            "float": float,
            "bool": bool,
            "list": list,
            "dict": dict,
        }

        # Add body model if created
        if body_model:
            exec_globals["RequestBody"] = body_model

        # Execute the function definition
        exec(func_code, exec_globals)

        return exec_globals["endpoint_wrapper"]

    def _get_python_type(self, type_string: str) -> Type[Any]:
        """Convert string type to Python type."""
        type_mapping: Dict[str, Type[Any]] = {
            "str": str,
            "string": str,
            "int": int,
            "integer": int,
            "float": float,
            "number": float,
            "bool": bool,
            "boolean": bool,
            "list": list,
            "dict": dict,
            "object": dict,
        }
        return type_mapping.get(type_string.lower(), str)

    def _create_response_model(
        self, response_config: Optional[Dict[str, Any]] = None
    ) -> Optional[Type[BaseModel]]:
        """Create a Pydantic response model from configuration."""
        if not response_config:
            return None

        model_name = response_config.get("name", "ResponseModel")
        fields = response_config.get("fields", {})

        if not fields:
            return None

        # Convert field definitions to Pydantic field format
        pydantic_fields: Dict[str, Any] = {}
        for field_name, field_config in fields.items():
            field_type = self._get_python_type(field_config.get("type", "str"))
            required = field_config.get("required", True)
            description = field_config.get("description", "")

            if required:
                pydantic_fields[field_name] = (
                    field_type,
                    Field(..., description=description),
                )
            else:
                default_value = field_config.get("default")
                pydantic_fields[field_name] = (
                    Optional[field_type],
                    Field(default_value, description=description),
                )

        # Create and cache the model
        model = create_model(model_name, **pydantic_fields)  # type: ignore[misc]
        self._models[model_name] = model
        return model

    def get_app(self) -> FastAPI:
        """
        Get the underlying FastAPI application instance.
        """
        return self.app
